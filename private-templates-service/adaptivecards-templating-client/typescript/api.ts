/**
 * adaptivecards-templating-service-javascript-sdk
 * Adaptive Cards Templating Service API definition.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost:5000';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];

class ObjectSerializer {

  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) { // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {// is Enum
        return data;
      }

      if (!typeMap[type]) { // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
      }
      return instance;
    }
  }
}

export class BaseError {
  'error'?: BaseErrorError;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "error",
      "baseName": "error",
      "type": "BaseErrorError"
    }];

  static getAttributeTypeMap() {
    return BaseError.attributeTypeMap;
  }
}

export class BaseErrorError {
  'code'?: string;
  'message'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "code",
      "baseName": "code",
      "type": "string"
    },
    {
      "name": "message",
      "baseName": "message",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return BaseErrorError.attributeTypeMap;
  }
}

export class Config {
  'appId'?: string;
  'redirectUri'?: string;
  'appInsightsInstrumentationKey'?: string;
  'userInsightsInstrumentationKey'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "appId",
      "baseName": "appId",
      "type": "string"
    },
    {
      "name": "redirectUri",
      "baseName": "redirectUri",
      "type": "string"
    },
    {
      "name": "appInsightsInstrumentationKey",
      "baseName": "appInsightsInstrumentationKey",
      "type": "string"
    },
    {
      "name": "userInsightsInstrumentationKey",
      "baseName": "userInsightsInstrumentationKey",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return Config.attributeTypeMap;
  }
}

export class FavoriteTagList {
  'favorite'?: TagList;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "favorite",
      "baseName": "favorite",
      "type": "TagList"
    }];

  static getAttributeTypeMap() {
    return FavoriteTagList.attributeTypeMap;
  }
}

export class PostedTemplate {
  'name'?: string;
  'version'?: string;
  'template'?: any;
  'state'?: PostedTemplate.StateEnum;
  'isShareable'?: boolean;
  'isPublished'?: boolean;
  'tags'?: Array<string>;
  'data'?: Array<any>;
  'isClient'?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "name",
      "baseName": "name",
      "type": "string"
    },
    {
      "name": "version",
      "baseName": "version",
      "type": "string"
    },
    {
      "name": "template",
      "baseName": "template",
      "type": "any"
    },
    {
      "name": "state",
      "baseName": "state",
      "type": "PostedTemplate.StateEnum"
    },
    {
      "name": "isShareable",
      "baseName": "isShareable",
      "type": "boolean"
    },
    {
      "name": "isPublished",
      "baseName": "isPublished",
      "type": "boolean"
    },
    {
      "name": "tags",
      "baseName": "tags",
      "type": "Array<string>"
    },
    {
      "name": "data",
      "baseName": "data",
      "type": "Array<any>"
    },
    {
      "name": "isClient",
      "baseName": "isClient",
      "type": "boolean"
    }];

  static getAttributeTypeMap() {
    return PostedTemplate.attributeTypeMap;
  }
}

export namespace PostedTemplate {
  export enum StateEnum {
    Draft = <any>'draft',
    Live = <any>'live',
    Deprecated = <any>'deprecated'
  }
}
export class Recent {
  'recentlyViewed'?: TemplateList;
  'recentlyEdited'?: TemplateList;
  'recentlyUsed'?: TagList;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "recentlyViewed",
      "baseName": "recentlyViewed",
      "type": "TemplateList"
    },
    {
      "name": "recentlyEdited",
      "baseName": "recentlyEdited",
      "type": "TemplateList"
    },
    {
      "name": "recentlyUsed",
      "baseName": "recentlyUsed",
      "type": "TagList"
    }];

  static getAttributeTypeMap() {
    return Recent.attributeTypeMap;
  }
}

export class ResourceCreated {
  'id'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "id",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return ResourceCreated.attributeTypeMap;
  }
}

export class TagList {
  'ownedTags'?: Array<string>;
  'allTags'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "ownedTags",
      "baseName": "ownedTags",
      "type": "Array<string>"
    },
    {
      "name": "allTags",
      "baseName": "allTags",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return TagList.attributeTypeMap;
  }
}

export class Tags {
  'ownedTags'?: Array<string>;
  'allTags'?: Array<string>;
  'favoriteTags'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "ownedTags",
      "baseName": "ownedTags",
      "type": "Array<string>"
    },
    {
      "name": "allTags",
      "baseName": "allTags",
      "type": "Array<string>"
    },
    {
      "name": "favoriteTags",
      "baseName": "favoriteTags",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return Tags.attributeTypeMap;
  }
}

export class Template {
  'id'?: string;
  'name'?: string;
  'instances'?: Array<TemplateInstance>;
  'authors'?: Array<string>;
  'isLive'?: boolean;
  'createdAt'?: string;
  'updatedAt'?: string;
  'tags'?: Array<string>;
  'deletedVersions'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "name",
      "baseName": "name",
      "type": "string"
    },
    {
      "name": "instances",
      "baseName": "instances",
      "type": "Array<TemplateInstance>"
    },
    {
      "name": "authors",
      "baseName": "authors",
      "type": "Array<string>"
    },
    {
      "name": "isLive",
      "baseName": "isLive",
      "type": "boolean"
    },
    {
      "name": "createdAt",
      "baseName": "createdAt",
      "type": "string"
    },
    {
      "name": "updatedAt",
      "baseName": "updatedAt",
      "type": "string"
    },
    {
      "name": "tags",
      "baseName": "tags",
      "type": "Array<string>"
    },
    {
      "name": "deletedVersions",
      "baseName": "deletedVersions",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return Template.attributeTypeMap;
  }
}

export class TemplateInfo {
  'id'?: string;
  'name'?: string;
  'instance'?: TemplatePreviewInstance;
  'tags'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "name",
      "baseName": "name",
      "type": "string"
    },
    {
      "name": "instance",
      "baseName": "instance",
      "type": "TemplatePreviewInstance"
    },
    {
      "name": "tags",
      "baseName": "tags",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return TemplateInfo.attributeTypeMap;
  }
}

export class TemplateInstance {
  'id'?: string;
  'json'?: any;
  'version'?: string;
  'publishedAt'?: string;
  'state'?: TemplateInstance.StateEnum;
  'author'?: string;
  'isShareable'?: boolean;
  'numHits'?: number;
  'data'?: Array<any>;
  'updatedAt'?: string;
  'createdAt'?: string;
  'lastEditedUser'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "json",
      "baseName": "json",
      "type": "any"
    },
    {
      "name": "version",
      "baseName": "version",
      "type": "string"
    },
    {
      "name": "publishedAt",
      "baseName": "publishedAt",
      "type": "string"
    },
    {
      "name": "state",
      "baseName": "state",
      "type": "TemplateInstance.StateEnum"
    },
    {
      "name": "author",
      "baseName": "author",
      "type": "string"
    },
    {
      "name": "isShareable",
      "baseName": "isShareable",
      "type": "boolean"
    },
    {
      "name": "numHits",
      "baseName": "numHits",
      "type": "number"
    },
    {
      "name": "data",
      "baseName": "data",
      "type": "Array<any>"
    },
    {
      "name": "updatedAt",
      "baseName": "updatedAt",
      "type": "string"
    },
    {
      "name": "createdAt",
      "baseName": "createdAt",
      "type": "string"
    },
    {
      "name": "lastEditedUser",
      "baseName": "lastEditedUser",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return TemplateInstance.attributeTypeMap;
  }
}

export namespace TemplateInstance {
  export enum StateEnum {
    Draft = <any>'draft',
    Live = <any>'live',
    Deprecated = <any>'deprecated'
  }
}
export class TemplateList {
  'templates'?: Array<Template>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "templates",
      "baseName": "templates",
      "type": "Array<Template>"
    }];

  static getAttributeTypeMap() {
    return TemplateList.attributeTypeMap;
  }
}

export class TemplatePreview {
  'template'?: TemplateInfo;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "template",
      "baseName": "template",
      "type": "TemplateInfo"
    }];

  static getAttributeTypeMap() {
    return TemplatePreview.attributeTypeMap;
  }
}

export class TemplatePreviewInstance {
  'version'?: string;
  'json'?: any;
  'state'?: string;
  'author'?: string;
  'data'?: Array<any>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "version",
      "baseName": "version",
      "type": "string"
    },
    {
      "name": "json",
      "baseName": "json",
      "type": "any"
    },
    {
      "name": "state",
      "baseName": "state",
      "type": "string"
    },
    {
      "name": "author",
      "baseName": "author",
      "type": "string"
    },
    {
      "name": "data",
      "baseName": "data",
      "type": "Array<any>"
    }];

  static getAttributeTypeMap() {
    return TemplatePreviewInstance.attributeTypeMap;
  }
}

export class UpdateTemplateState {
  'version'?: string;
  'state'?: UpdateTemplateState.StateEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "version",
      "baseName": "version",
      "type": "string"
    },
    {
      "name": "state",
      "baseName": "state",
      "type": "UpdateTemplateState.StateEnum"
    }];

  static getAttributeTypeMap() {
    return UpdateTemplateState.attributeTypeMap;
  }
}

export namespace UpdateTemplateState {
  export enum StateEnum {
    Draft = <any>'draft',
    Live = <any>'live',
    Deprecated = <any>'deprecated'
  }
}
export class UpdateTemplateStateList {
  'templates'?: Array<UpdateTemplateState>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "templates",
      "baseName": "templates",
      "type": "Array<UpdateTemplateState>"
    }];

  static getAttributeTypeMap() {
    return UpdateTemplateStateList.attributeTypeMap;
  }
}

export class User {
  'id'?: string;
  'authId'?: string;
  'authIssuer'?: string;
  'recentlyViewed'?: Array<string>;
  'recentlyEdited'?: Array<string>;
  'recentTags'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "authId",
      "baseName": "authId",
      "type": "string"
    },
    {
      "name": "authIssuer",
      "baseName": "authIssuer",
      "type": "string"
    },
    {
      "name": "recentlyViewed",
      "baseName": "recentlyViewed",
      "type": "Array<string>"
    },
    {
      "name": "recentlyEdited",
      "baseName": "recentlyEdited",
      "type": "Array<string>"
    },
    {
      "name": "recentTags",
      "baseName": "recentTags",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return User.attributeTypeMap;
  }
}

export class UserList {
  'user'?: Array<User>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "user",
      "baseName": "user",
      "type": "Array<User>"
    }];

  static getAttributeTypeMap() {
    return UserList.attributeTypeMap;
  }
}

export class VersionList {
  'versions'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "versions",
      "baseName": "versions",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return VersionList.attributeTypeMap;
  }
}


let enumsMap: { [index: string]: any } = {
  "PostedTemplate.StateEnum": PostedTemplate.StateEnum,
  "TemplateInstance.StateEnum": TemplateInstance.StateEnum,
  "UpdateTemplateState.StateEnum": UpdateTemplateState.StateEnum,
}

let typeMap: { [index: string]: any } = {
  "BaseError": BaseError,
  "BaseErrorError": BaseErrorError,
  "Config": Config,
  "FavoriteTagList": FavoriteTagList,
  "PostedTemplate": PostedTemplate,
  "Recent": Recent,
  "ResourceCreated": ResourceCreated,
  "TagList": TagList,
  "Tags": Tags,
  "Template": Template,
  "TemplateInfo": TemplateInfo,
  "TemplateInstance": TemplateInstance,
  "TemplateList": TemplateList,
  "TemplatePreview": TemplatePreview,
  "TemplatePreviewInstance": TemplatePreviewInstance,
  "UpdateTemplateState": UpdateTemplateState,
  "UpdateTemplateStateList": UpdateTemplateStateList,
  "User": User,
  "UserList": UserList,
  "VersionList": VersionList,
}

export interface Authentication {
  /**
  * Apply authentication settings to header and query params.
  */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username, password: this.password
    }
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = '';

  constructor(private location: string, private paramName: string) {
  }

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (this.location == "header" && requestOptions && requestOptions.headers) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum ConfigApiApiKeys {
  bearer_auth,
}

export class ConfigApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ConfigApiApiKeys, value: string) {
    (this.authentications as any)[ConfigApiApiKeys[key]].apiKey = value;
  }
  /**
   * 
   * @summary Get auth provider specific env values
   * @param {*} [options] Override http request options.
   */
  public configGet(options: any = {}): Promise<{ response: http.IncomingMessage; body: Config; }> {
    const localVarPath = this.basePath + '/config';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Config; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {

          body = ObjectSerializer.deserialize(body, "Config");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum DefaultApiApiKeys {
  bearer_auth,
}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }
  /**
   * 
   * @summary Unfavorite tags
   * @param body list of favorite tags
   * @param {*} [options] Override http request options.
   */
  public unFavoriteTags(body: FavoriteTagList, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/tag';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling unFavoriteTags.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "FavoriteTagList")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Favorite tags
   * @param body list of favorite tags
   * @param {*} [options] Override http request options.
   */
  public updateTags(body: FavoriteTagList, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/tag';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateTags.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "FavoriteTagList")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum TemplateApiApiKeys {
  bearer_auth,
}

export class TemplateApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TemplateApiApiKeys, value: string) {
    (this.authentications as any)[TemplateApiApiKeys[key]].apiKey = value;
  }

  /**
 *
 * @summary Get list of owned, favorite, and all tags
 * @param {*} [options] Override http request options.
 */
  public allTags(options: any = {}): Promise<{ response: http.IncomingMessage; body: Tags; }> {
    const localVarPath = this.basePath + '/template/tag';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Tags; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Tags");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }

  /**
   * Returns the latest version of all public templates and owned templates
   * @summary Find all templates
   * @param state Query based on if template state
   * @param isClient If true, ignores updating hits on template
   * @param name Name of template to query for
   * @param version Version of template
   * @param owned Display only the templates where the user authored a version
   * @param sortBy Sort returned templates by parameter
   * @param sortOrder 
   * @param tags List of tags to filter templates by
   * @param {*} [options] Override http request options.
   */
  public allTemplates(state?: 'live' | 'draft' | 'deprecated', isClient?: boolean, name?: string, version?: string, owned?: boolean, sortBy?: 'alphabetical' | 'dateCreated' | 'dateUpdated', sortOrder?: 'ascending' | 'descending', tags?: Array<string>, options: any = {}): Promise<{ response: http.IncomingMessage; body: TemplateList; }> {
    const localVarPath = this.basePath + '/template';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    if (state !== undefined) {
      localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'live' | 'draft' | 'deprecated'");
    }

    if (isClient !== undefined) {
      localVarQueryParameters['isClient'] = ObjectSerializer.serialize(isClient, "boolean");
    }

    if (name !== undefined) {
      localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
    }

    if (version !== undefined) {
      localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
    }

    if (owned !== undefined) {
      localVarQueryParameters['owned'] = ObjectSerializer.serialize(owned, "boolean");
    }

    if (sortBy !== undefined) {
      localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "'alphabetical' | 'dateCreated' | 'dateUpdated'");
    }
    if (sortOrder !== undefined) {
      localVarQueryParameters['sortOrder'] = ObjectSerializer.serialize(sortOrder, "'ascending' | 'descending'");
    }

    if (tags !== undefined) {
      localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TemplateList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "TemplateList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }

  /**
   * 
   * @summary Batch delete template version operation
   * @param templateId ID of template to update
   * @param versionList template versions to delete
   * @param {*} [options] Override http request options.
   */
  public batchTemplateDelete(templateId: string, versionList: VersionList, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/{templateId}/batch'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling batchTemplateDelete.');
    }

    // verify required parameter 'versionList' is not null or undefined
    if (versionList === null || versionList === undefined) {
      throw new Error('Required parameter versionList was null or undefined when calling batchTemplateDelete.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(versionList, "VersionList")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Update existing template given id
   * @summary Batch update template states
   * @param templateId ID of template to update
   * @param body list of template versions and desired states
   * @param {*} [options] Override http request options.
   */
  public batchTemplateUpdate(templateId: string, body: UpdateTemplateStateList, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/{templateId}/batch'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling batchTemplateUpdate.');
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling batchTemplateUpdate.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "UpdateTemplateStateList")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Add a new template
   * @param body Template object to be added
   * @param {*} [options] Override http request options.
   */
  public createTemplate(body: PostedTemplate, options: any = {}): Promise<{ response: http.IncomingMessage; body: ResourceCreated; }> {
    const localVarPath = this.basePath + '/template';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createTemplate.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PostedTemplate")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: ResourceCreated; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ResourceCreated");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Delete version of template, default latest
   * @param templateId ID of template to return
   * @param version Version of template to delete
   * @param {*} [options] Override http request options.
   */
  public deleteTemplateById(templateId: string, version?: string, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/{templateId}'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling deleteTemplateById.');
    }

    if (version !== undefined) {
      localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Get recently viewed, edited templates, and recent tags.
   * @param {*} [options] Override http request options.
   */
  public getRecent(options: any = {}): Promise<{ response: http.IncomingMessage; body: Recent; }> {
    const localVarPath = this.basePath + '/template/recent';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Recent; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Recent");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Update existing template given id
   * @summary Update existing template
   * @param templateId ID of template to update
   * @param body Template object to be added
   * @param {*} [options] Override http request options.
   */
  public postTemplateById(templateId: string, body: PostedTemplate, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/{templateId}'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling postTemplateById.');
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling postTemplateById.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PostedTemplate")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns a single template
   * @summary Find template by id
   * @param templateId ID of template to return
   * @param state Query based on if template state
   * @param isClient If true, ignores updating hits on template
   * @param version Version of template to return
   * @param {*} [options] Override http request options.
   */
  public templateById(templateId: string, state?: 'live' | 'draft' | 'deprecated', isClient?: boolean, version?: string, options: any = {}): Promise<{ response: http.IncomingMessage; body: TemplateList; }> {
    const localVarPath = this.basePath + '/template/{templateId}'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling templateById.');
    }

    if (state !== undefined) {
      localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'live' | 'draft' | 'deprecated'");
    }

    if (isClient !== undefined) {
      localVarQueryParameters['isClient'] = ObjectSerializer.serialize(isClient, "boolean");
    }

    if (version !== undefined) {
      localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TemplateList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "TemplateList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Get template preview
   * @param templateId ID of template to return
   * @param version Version of template to preview
   * @param {*} [options] Override http request options.
   */
  public templatePreview(templateId: string, version: string, options: any = {}): Promise<{ response: http.IncomingMessage; body: TemplatePreview; }> {
    const localVarPath = this.basePath + '/template/{templateId}/preview'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling templatePreview.');
    }

    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined) {
      throw new Error('Required parameter version was null or undefined when calling templatePreview.');
    }

    if (version !== undefined) {
      localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TemplatePreview; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "TemplatePreview");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum UserApiApiKeys {
  bearer_auth,
}

export class UserApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UserApiApiKeys, value: string) {
    (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
  }
  /**
   * Delete all user info and user owner templates
   * @summary Delete all user info
   * @param {*} [options] Override http request options.
   */
  public userDelete(options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns user's info
   * @summary Get user's info
   * @param {*} [options] Override http request options.
   */
  public userGet(options: any = {}): Promise<{ response: http.IncomingMessage; body: UserList; }> {
    const localVarPath = this.basePath + '/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: UserList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "UserList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
