/**
 * adaptivecards-templating-service-javascript-sdk
 * Adaptive Cards Templating Service API definition.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost:3000';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];

class ObjectSerializer {

  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) { // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {// is Enum
        return data;
      }

      if (!typeMap[type]) { // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
      }
      return instance;
    }
  }
}

export class BaseError {
  'error'?: BaseErrorError;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "error",
      "baseName": "error",
      "type": "BaseErrorError"
    }];

  static getAttributeTypeMap() {
    return BaseError.attributeTypeMap;
  }
}

export class BaseErrorError {
  'code'?: string;
  'message'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "code",
      "baseName": "code",
      "type": "string"
    },
    {
      "name": "message",
      "baseName": "message",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return BaseErrorError.attributeTypeMap;
  }
}

export class ResourceCreated {
  'id'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "id",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return ResourceCreated.attributeTypeMap;
  }
}

export class Template {
  'id'?: string;
  'name'?: string;
  'instances'?: Array<TemplateInstance>;
  'owner'?: string;
  'isPublished'?: boolean;
  'createdAt'?: string;
  'updatedAt'?: string;
  'tags'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "name",
      "baseName": "name",
      "type": "string"
    },
    {
      "name": "instances",
      "baseName": "instances",
      "type": "Array<TemplateInstance>"
    },
    {
      "name": "owner",
      "baseName": "owner",
      "type": "string"
    },
    {
      "name": "isPublished",
      "baseName": "isPublished",
      "type": "boolean"
    },
    {
      "name": "createdAt",
      "baseName": "createdAt",
      "type": "string"
    },
    {
      "name": "updatedAt",
      "baseName": "updatedAt",
      "type": "string"
    },
    {
      "name": "tags",
      "baseName": "tags",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return Template.attributeTypeMap;
  }
}

export class TemplateInstance {
  'json'?: string;
  'version'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "json",
      "baseName": "json",
      "type": "string"
    },
    {
      "name": "version",
      "baseName": "version",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return TemplateInstance.attributeTypeMap;
  }
}

export class TemplateJSON {
  'template'?: string;
  'isPublished'?: boolean;
  'name'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "template",
      "baseName": "template",
      "type": "string"
    },
    {
      "name": "isPublished",
      "baseName": "isPublished",
      "type": "boolean"
    },
    {
      "name": "name",
      "baseName": "name",
      "type": "string"
    }];

  static getAttributeTypeMap() {
    return TemplateJSON.attributeTypeMap;
  }
}

export class TemplateList {
  'templates'?: Array<Template>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "templates",
      "baseName": "templates",
      "type": "Array<Template>"
    }];

  static getAttributeTypeMap() {
    return TemplateList.attributeTypeMap;
  }
}

export class User {
  'id'?: string;
  'authId'?: string;
  'issuer'?: string;
  'team'?: Array<string>;
  'org'?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "id",
      "baseName": "_id",
      "type": "string"
    },
    {
      "name": "authId",
      "baseName": "authId",
      "type": "string"
    },
    {
      "name": "issuer",
      "baseName": "issuer",
      "type": "string"
    },
    {
      "name": "team",
      "baseName": "team",
      "type": "Array<string>"
    },
    {
      "name": "org",
      "baseName": "org",
      "type": "Array<string>"
    }];

  static getAttributeTypeMap() {
    return User.attributeTypeMap;
  }
}

export class UserList {
  'user'?: Array<User>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{ name: string, baseName: string, type: string }> = [
    {
      "name": "user",
      "baseName": "user",
      "type": "Array<User>"
    }];

  static getAttributeTypeMap() {
    return UserList.attributeTypeMap;
  }
}


let enumsMap: { [index: string]: any } = {
}

let typeMap: { [index: string]: any } = {
  "BaseError": BaseError,
  "BaseErrorError": BaseErrorError,
  "ResourceCreated": ResourceCreated,
  "Template": Template,
  "TemplateInstance": TemplateInstance,
  "TemplateJSON": TemplateJSON,
  "TemplateList": TemplateList,
  "User": User,
  "UserList": UserList,
}

export interface Authentication {
  /**
  * Apply authentication settings to header and query params.
  */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username, password: this.password
    }
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = '';

  constructor(private location: string, private paramName: string) {
  }

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (this.location == "header" && requestOptions && requestOptions.headers) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum TemplateApiApiKeys {
  bearer_auth,
}

export class TemplateApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TemplateApiApiKeys, value: string) {
    (this.authentications as any)[TemplateApiApiKeys[key]].apiKey = value;
  }
  /**
   * Returns a single template
   * @summary Find template by id
   * @param templateId ID of template to return
   * @param {*} [options] Override http request options.
   */
  public templateById(templateId: string, options: any = {}): Promise<{ response: http.IncomingMessage; body: TemplateList; }> {
    const localVarPath = this.basePath + '/template/{templateId}'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling templateById.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TemplateList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "TemplateList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns all public templates and owned templates
   * @summary Find all templates
   * @param isPublished Query based on if template is published
   * @param name Name of template to query for
   * @param version Version of template
   * @param owned Display only the templates owned by the user
   * @param {*} [options] Override http request options.
   */
  public templateGet(isPublished?: boolean, name?: string, version?: string, owned?: boolean, options: any = {}): Promise<{ response: http.IncomingMessage; body: TemplateList; }> {
    const localVarPath = this.basePath + '/template';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    if (isPublished !== undefined) {
      localVarQueryParameters['isPublished'] = ObjectSerializer.serialize(isPublished, "boolean");
    }

    if (name !== undefined) {
      localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
    }

    if (version !== undefined) {
      localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "string");
    }

    if (owned !== undefined) {
      localVarQueryParameters['owned'] = ObjectSerializer.serialize(owned, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TemplateList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "TemplateList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * 
   * @summary Add a new template
   * @param body Template object to be added
   * @param {*} [options] Override http request options.
   */
  public templatePost(body: TemplateJSON, options: any = {}): Promise<{ response: http.IncomingMessage; body: ResourceCreated; }> {
    const localVarPath = this.basePath + '/template';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling templatePost.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "TemplateJSON")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: ResourceCreated; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ResourceCreated");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Update existing template given id
   * @summary Update existing template
   * @param templateId ID of template to update
   * @param body Template object to be added
   * @param {*} [options] Override http request options.
   */
  public templateTemplateIdPost(templateId: string, body: TemplateJSON, options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/template/{templateId}'
      .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error('Required parameter templateId was null or undefined when calling templateTemplateIdPost.');
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling templateTemplateIdPost.');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "TemplateJSON")
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum UserApiApiKeys {
  bearer_auth,
}

export class UserApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
    'bearer_auth': new ApiKeyAuth('header', 'Authorization'),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UserApiApiKeys, value: string) {
    (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
  }
  /**
   * Delete all user info and user owner templates
   * @summary Delete all user info
   * @param {*} [options] Override http request options.
   */
  public userDelete(options: any = {}): Promise<{ response: http.IncomingMessage; body?: any; }> {
    const localVarPath = this.basePath + '/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns user's info
   * @summary Get user's info
   * @param {*} [options] Override http request options.
   */
  public userGet(options: any = {}): Promise<{ response: http.IncomingMessage; body: UserList; }> {
    const localVarPath = this.basePath + '/user';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.bearer_auth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: UserList; }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "UserList");
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
